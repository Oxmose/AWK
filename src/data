diff -Naur psys-base.ori/kernel/bioscall.h psys-base/kernel/bioscall.h
--- psys-base.ori/kernel/bioscall.h	1970-01-01 01:00:00.000000000 +0100
+++ psys-base/kernel/bioscall.h	2010-06-02 10:59:55.265863510 +0200
@@ -0,0 +1,54 @@
+/*******************************************************************************
+bioscall.h
+
+Copyright (C) 2000 Simon Nieuviarts
+
+This module does BIOS calls in real mode.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version. 
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*******************************************************************************/
+#ifndef __BIOSCALL_H__
+#define __BIOSCALL_H__
+
+
+#define REGX(a) ((a) & 0xffff)
+#define REGL(a) ((a) & 0xff)
+#define REGH(a) (((a) >> 8) & 0xff)
+
+
+/* A structure to store the registers used in a BIOS call. */
+struct bios_regs {
+	unsigned int eax;
+	unsigned int ebx;
+	unsigned int ecx;
+	unsigned int edx;
+	unsigned int esi;
+	unsigned int edi;
+	unsigned int ebp;
+	unsigned int esp;
+	unsigned int eflags;
+	unsigned short ds;
+	unsigned short es;
+	unsigned short fs;
+	unsigned short gs;
+	unsigned short ss;
+};
+
+
+void do_bios_call(struct bios_regs *regs, unsigned char int_no);
+
+
+#endif
+
diff -Naur psys-base.ori/kernel/bioscall.S psys-base/kernel/bioscall.S
--- psys-base.ori/kernel/bioscall.S	1970-01-01 01:00:00.000000000 +0100
+++ psys-base/kernel/bioscall.S	2010-06-02 11:13:52.410364458 +0200
@@ -0,0 +1,101 @@
+/*******************************************************************************
+bioscall-wrapper.S
+
+Copyright (C) 2000 Simon Nieuviarts
+
+This code is the wrapping code of do_bios_call for our kernel.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version. 
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*******************************************************************************/
+	.text
+/*******************************************************************************
+void do_bios_call( bios_regs *regs, unsigned char int_no )
+This is the single function of the module. It must be called in 32-bit protected
+mode, without paging, and with CS, DS, ES and SS pointing to 32-bit segments
+starting at 0.
+The general registers are unchanged. Interrupts are disabled.
+*******************************************************************************/
+	.global do_bios_call
+do_bios_call:
+	testb	$0xff,init_done
+	jnz	0f
+
+	/* Copy the rmcode at 0x2000. */
+	movb	$0x01,init_done
+	pushl	%esi
+	pushl	%edi
+	leal	rmcode_end,%ecx
+	leal	rmcode_start,%esi
+	leal	0x2000,%edi
+	subl	%esi,%ecx
+	addl	$3,%ecx
+	sarl	$2,%ecx
+	cld
+	rep
+	movsl
+	popl	%edi
+	popl	%esi
+
+0:	/* Real mode code copied at 0x2000. */
+	movl	4(%esp),%ecx
+	movl	8(%esp),%edx
+
+	pushfl
+	cli
+
+	/* Save the kernel IDT and GDT and segment registers. */
+	sgdt	gdt_loc
+	sidt	idt_loc
+	pushw	%ds
+	pushw	%es
+	pushw	%fs
+	pushw	%gs
+	pushw	%ss
+	lcall	$0x10,$0f
+	popw	%ss
+	popw	%gs
+	popw	%fs
+	popw	%es
+	popw	%ds
+	popfl
+	ret
+
+0:	/* Segments and interrupts stuff are saved. */
+	pushl	%edx
+	pushl	%ecx
+	call	0x2000
+	addl	$8,%esp
+
+	/* Restore the kernel IDT and GDT and segment registers. */
+	lidt	idt_loc
+	lgdt	gdt_loc
+	lret
+
+	.data
+init_done:
+	.byte	0
+
+	.align  2
+	/* Location of the kernel IDT. */
+idt_loc:
+	.word   0
+	.long   0
+
+	.align  2
+	/* Location of the kernel GDT. */
+gdt_loc:
+	.word   0
+	.long   0
+
diff -Naur psys-base.ori/kernel/kernel.lds psys-base/kernel/kernel.lds
--- psys-base.ori/kernel/kernel.lds	2007-01-24 15:33:11.971391000 +0100
+++ psys-base/kernel/kernel.lds	2010-06-02 11:01:57.977852044 +0200
@@ -42,6 +42,11 @@
 		*(.user)
 		usercode_end = .;
 
+		/* The real mode code too */
+		rmcode_start = .;
+		*(.rmcode)
+		rmcode_end = .;
+
 		task_dump_screen = .;
 		*(.task_dump_screen)
 
diff -Naur psys-base.ori/kernel/Makefile psys-base/kernel/Makefile
--- psys-base.ori/kernel/Makefile	2010-05-21 09:49:02.751460000 +0200
+++ psys-base/kernel/Makefile	2010-06-02 11:06:51.802987575 +0200
@@ -5,7 +5,8 @@
 DIRS=. ../shared
 
 # crt0.o must be the first object linked
-OBJS=$(strip crt0.o $(filter-out crt0.o,$(notdir $(patsubst %.S,%.o,$(patsubst %.c,%.o,$(FILES))))))
+# rmcode.o must not be included
+OBJS=$(strip crt0.o $(filter-out crt0.o rmcode.o,$(notdir $(patsubst %.S,%.o,$(patsubst %.c,%.o,$(FILES))))))
 
 CC=gcc -m32
 AS=gcc -m32
@@ -18,7 +19,7 @@
 INC=$(patsubst %,-I%,$(DIRS))
 CCL=$(CC) -Werror $(KFLAGS) $(DEF) $(INC)
 ASL=$(AS) -DASSEMBLER $(DEF) $(INC)
-DEPS=$(patsubst %.o,%.d,$(OBJS))
+DEPS=$(patsubst %.o,%.d,$(OBJS)) rmcode.d
 
 # Where to search for source files
 vpath %.c $(DIRS)
@@ -67,10 +68,19 @@
 task_dump_screen.o: empty.o task_dump_screen.txt
 	objcopy empty.o --add-section=.task_dump_screen=task_dump_screen.txt --set-section-flags=.task_dump_screen=contents,alloc,load,data task_dump_screen.o
 
+# A small real mode program to do BIOS call
+# Only useful for some extensions such as graphics programming
+rmcode.bin: rmcode.o
+	$(LD) -e do_bios_call_rm -Ttext 0x2000 rmcode.o --oformat binary -o rmcode.bin
+
+rmcode_data.o: empty.o rmcode.bin
+	objcopy empty.o --add-section=.rmcode=rmcode.bin --set-section-flags=.rmcode=contents,alloc,load,data rmcode_data.o
+
 # Generate the kernel, ready to run
-kernel.bin: kernel.lds $(OBJS) userdata.o kbd_linux/kbd_linux.o task_dump_screen.o
-	$(LD) -e entry -Tkernel.lds $(OBJS) userdata.o kbd_linux/kbd_linux.o task_dump_screen.o -o $@
+kernel.bin: kernel.lds $(OBJS) userdata.o kbd_linux/kbd_linux.o task_dump_screen.o rmcode_data.o
+	$(LD) -e entry -Tkernel.lds $(OBJS) userdata.o kbd_linux/kbd_linux.o task_dump_screen.o rmcode_data.o -o $@
 
 clean:
 	make -C kbd_linux clean
-	rm -f $(OBJS) $(DEPS) kernel.bin userdata.o task_dump_screen.o
+	rm -f $(OBJS) $(DEPS) kernel.bin userdata.o task_dump_screen.o rmcode.bin rmcode.o rmcode_data.o
+
diff -Naur psys-base.ori/kernel/rmcode.S psys-base/kernel/rmcode.S
--- psys-base.ori/kernel/rmcode.S	1970-01-01 01:00:00.000000000 +0100
+++ psys-base/kernel/rmcode.S	2010-06-02 11:10:57.753879508 +0200
@@ -0,0 +1,239 @@
+/*******************************************************************************
+rmcode.S
+
+Copyright (C) 2000 Simon Nieuviarts
+
+This code is used to do BIOS calls.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version. 
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*******************************************************************************/
+#define ADR(x) (x-do_bios_call_rm+0x2000)
+#define REGS_LEN (9*4+5*2)
+#define REGS_EAX 0
+#define REGS_EBX 4
+#define REGS_ECX 8
+#define REGS_EDX 12
+#define REGS_ESI 16
+#define REGS_EDI 20
+#define REGS_EBP 24
+#define REGS_ESP 28
+#define REGS_EFLAGS 32
+#define REGS_DS  36
+#define REGS_ES  38
+#define REGS_FS  40
+#define REGS_GS  42
+#define REGS_SS  44
+
+	.text
+/*******************************************************************************
+void do_bios_call( bios_regs *regs, unsigned char int_no )
+This is the single function of the module. It must be called in 32-bit protected
+mode, without paging, and with CS, DS, ES and SS pointing to 32-bit segments
+starting at 0.
+On exit, the IDTR and the GDTR are left in an invalid state. The segment
+registers point to 32-bit segments with an offset of 0 and a limit of
+0xffffffff. The general registers are unchanged. Interrupts are disabled.
+*******************************************************************************/
+	.global do_bios_call_rm
+do_bios_call_rm:
+	.code32
+
+	/* Interrupts are disabled. */
+	cli
+
+	/* Save the registers on the stack. */
+	pushfl
+	pushal
+
+	/* Save the cr0 and cr3 register. */
+	movl	%cr0,%eax
+	pushl	%eax
+	andl	$0x7fffffff,%eax
+	movl	%eax,%cr0
+	movl	%cr3,%eax
+	pushl	%eax
+	xorl	%eax,%eax
+	movl	%eax,%cr3
+
+	/* Load the GDTR to use our table. */
+	lgdt	ADR(lgdt_val)
+
+	/* Copy the interrupt vector of the interrupt we want to use to the
+	vector 0xF1 (a user reserved vector). */
+	movzbl	52(%esp),%eax	/* Skip cr0, cr3, pushal, pushf... */
+	movl	(,%eax,4),%eax
+	movl	%eax,0xF1*4
+
+	movl	%esp,ADR(esp_saved)	/* Save the stack pointer. */
+	movl	48(%esp),%esi		/* esi points to the regs buffer. */
+
+	/* Copy the regs buffer to our buffer. */
+	movl	$ADR(buffer),%edi
+	movl	$REGS_LEN,%ecx
+	cld
+	rep
+	movsb
+	subl	$REGS_LEN,%esi
+
+	movl	$0x20,%eax
+	movl	%eax,%ds
+	/* We can no more use the 32-bit datas. */
+
+	/* Now, we can load the CS register. */
+	ljmp	$0x18,$ADR(1f)
+1:
+	.code16
+	movl	%cr0,%esi
+	andl 	$0xfffffffe,%esi
+	movl	%esi,%cr0
+	ljmp	$0,$ADR(2f)
+2:	/* We are now in the real mode. */
+
+	/* Load the IDTR. */
+	lidt	ADR(lidt_val)
+
+	/* Load the stack pointer. */
+	movw	ADR(buffer+REGS_SS),%ax
+	movl	ADR(buffer+REGS_ESP),%edx
+	movw	%ax,%ss
+	movl	%edx,%esp
+
+	/* Load the low part of the eflags register. */
+	xorl	%eax,%eax
+	movb	ADR(buffer+REGS_EFLAGS),%al
+	pushl	%eax
+	popfl
+
+	/* Load the other general registers. */
+	movl	ADR(buffer+REGS_EAX),%eax
+	movl	ADR(buffer+REGS_EBX),%ebx
+	movl	ADR(buffer+REGS_ECX),%ecx
+	movl	ADR(buffer+REGS_EDX),%edx
+	movl	ADR(buffer+REGS_ESI),%esi
+	movl	ADR(buffer+REGS_EDI),%edi
+	movl	ADR(buffer+REGS_EBP),%ebp
+
+	/* Push the data segment registers on the stack. */
+	pushw	ADR(buffer+REGS_DS)
+	pushw	ADR(buffer+REGS_ES)
+	pushw	ADR(buffer+REGS_FS)
+	pushw	ADR(buffer+REGS_GS)
+
+	/* Load the data segment registers. */
+	popw	%gs
+	popw	%fs
+	popw	%es
+	popw	%ds
+
+	/* Execute the interrupt. */
+	int	$0xF1
+
+	/* Save EFLAGS on the stack. */
+	pushfl
+
+	/* Save the segment registers on the stack. */
+	pushw	%ds
+	pushw	%es
+	pushw	%fs
+	pushw	%gs
+
+	/* Save the registers in our buffer. */
+	pushw	%ax
+	xorw	%ax,%ax
+	movw	%ax,%ds
+	popw	%ax
+	popw	ADR(buffer+REGS_GS)
+	popw	ADR(buffer+REGS_FS)
+	popw	ADR(buffer+REGS_ES)
+	popw	ADR(buffer+REGS_DS)
+	popl	ADR(buffer+REGS_EFLAGS)
+	movl	%eax,ADR(buffer+REGS_EAX)
+	movl	%ebx,ADR(buffer+REGS_EBX)
+	movl	%ecx,ADR(buffer+REGS_ECX)
+	movl	%edx,ADR(buffer+REGS_EDX)
+	movl	%esi,ADR(buffer+REGS_ESI)
+	movl	%edi,ADR(buffer+REGS_EDI)
+	movl	%esp,ADR(buffer+REGS_ESP)
+	movl	%ebp,ADR(buffer+REGS_EBP)
+
+	/* All registers are saved. Return to the protected mode. */
+	cli
+	movw	$0x0010,%cx
+	movl	%cr0,%eax
+	orl	$1,%eax
+	movl	%eax,%cr0 
+	ljmp	$0x8,$ADR(3f)
+3:
+	.code32
+	movl	%ecx,%ds
+	movl	%ecx,%es
+	movl	%ecx,%fs
+	movl	%ecx,%gs
+	movl	%ecx,%ss
+	movl	ADR(esp_saved),%esp
+
+	/* Copy our buffer to the regs buffer. */
+	movl	48(%esp),%edi
+	movl	$ADR(buffer),%esi
+	movl	$REGS_LEN,%ecx
+	cld
+	rep
+	movsb
+
+	/* Restore the cr0 and cr3 register. */
+	popl	%eax
+	movl	%eax,%cr3
+	popl	%eax
+	movl	%eax,%cr0
+
+	popal
+	popfl
+	retl
+
+	.align  2
+	/* Location of the real mode IDT. */
+lidt_val:
+	.word   1023
+	.long   0
+
+	.align  2
+lgdt_val:
+	.word   5 * 8 - 1
+	.long   ADR(loader_gdt)
+
+	.align  4
+/* The GDT to switch to protected mode. */
+loader_gdt:
+/* 0: Null descriptor. */
+	.long	0, 0
+
+/* 1: A system code segment : 32-bit, 4G, base=0, CPL=0. */
+	.byte	0xFF, 0xFF, 0, 0, 0, 0x9B, 0xCF, 0
+
+/* 2: A system data segment : 4G, base=0, DPL=0. Also used for the stack. */
+	.byte	0xFF, 0xFF, 0, 0, 0, 0x93, 0xCF, 0
+
+/* 3: A code segment for the real mode : 16 bits, 64K, base=0, CPL=0. */
+	.byte	0xFF, 0xFF, 0, 0, 0, 0x9B, 0x00, 0
+
+/* 4: A data segment for the real mode : 16 bits, 64K, base=0, CPL=0. */
+	.byte	0xFF, 0xFF, 0, 0, 0, 0x93, 0x00, 0
+
+	.align  4
+esp_saved:
+	.long	0
+buffer:
+	.zero	REGS_LEN
+
